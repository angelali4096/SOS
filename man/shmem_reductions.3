.TH SHMEM_REDUCTIONS 1 2017-06-06 "Intel Corp." "OpenSHEMEM Library Documentation"
.SH NAME
shmem_reductions \-  Performs arithmetic and logical operations across a set of PEs.
.SH SYNOPSIS
.SS AND
Performs a bitwise AND function across a set of processing elements (PEs).
.br
.nf
.B C/C++: 
void shmem_short_and_to_all(short *dest, const short *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			short *pWrk, long *pSync);
void shmem_int_and_to_all(int *dest, const int *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			int *pWrk, long *pSync);
void shmem_long_and_to_all(long *dest, const long *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			long *pWrk, long *pSync);
void shmem_longlong_and_to_all(long long *dest, const long long *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			long long *pWrk, long *pSync);
.B FORTRAN: 
CALL SHMEM_INT4_AND_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, 
			PE_size, pWrk, pSync)
CALL SHMEM_INT8_AND_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, 
			PE_size, pWrk, pSync)
.fi
.SS MAX
Performs a maximum function reduction across a set of processing elements (PEs).
.br
.nf
.B C/C++: 
void shmem_short_max_to_all(short *dest, const short *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			short *pWrk, long *pSync);
void shmem_int_max_to_all(int *dest, const int *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			int *pWrk, long *pSync);
void shmem_double_max_to_all(double *dest, const double *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			double *pWrk, long *pSync);
void shmem_float_max_to_all(float *dest, const float *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			float *pWrk, long *pSync);
void shmem_long_max_to_all(long *dest, const long *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			long *pWrk, long *pSync);
void shmem_longdouble_max_to_all(long double *dest, 
			const long double *source, int nreduce, int PE_start, 
			int logPE_stride, int PE_size, long double *pWrk, 
			long *pSync);
void shmem_longlong_max_to_all(long long *dest, const long long *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			long long *pWrk, long *pSync);
.B FORTRAN: 
CALL SHMEM_INT4_MAX_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_MAX_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL4_MAX_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL8_MAX_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL16_MAX_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
.fi
.SS MIN
Performs a minimum function reduction across a set of processing elements (PEs).
.br
.nf
.B C/C++: 
void shmem_short_min_to_all(short *dest, const short *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			short *pWrk, long *pSync);
void shmem_int_min_to_all(int *dest, const int *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			int *pWrk, long *pSync);
void shmem_double_min_to_all(double *dest, const double *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			double *pWrk, long *pSync);
void shmem_float_min_to_all(float *dest, const float *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			float *pWrk, long *pSync);
void shmem_long_min_to_all(long *dest, const long *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			long *pWrk, long *pSync);
void shmem_longdouble_min_to_all(long double *dest, 
			const long double *source, int nreduce, int PE_start, 
			int logPE_stride, int PE_size, long double *pWrk, 
			long *pSync);
void shmem_longlong_min_to_all(long long *dest, 
			const long long *source, int nreduce, int PE_start, 
			int logPE_stride, int PE_size, long long *pWrk, 
			long *pSync);
.B FORTRAN: 
CALL SHMEM_INT4_MIN_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_MIN_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL4_MIN_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL8_MIN_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL16_MIN_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
.fi
.SS SUM
Performs a sum reduction across a set of processing elements (PEs).
.br
.nf
.B C/C++: 
void shmem_complexd_sum_to_all(double complex *dest, 
			const double complex *source, int nreduce, int PE_start, 
			int logPE_stride, int PE_size, double complex *pWrk, 
			long *pSync);
void shmem_complexf_sum_to_all(float complex *dest, 
			const float complex *source, int nreduce, int PE_start, 
			int logPE_stride, int PE_size, float complex *pWrk, 
			long *pSync);
void shmem_short_sum_to_all(short *dest, const short *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			short *pWrk, long *pSync);
void shmem_int_sum_to_all(int *dest, const int *source, int nreduce,
			int PE_start, int logPE_stride, int PE_size, int *pWrk,
			long *pSync);
void shmem_double_sum_to_all(double *dest, const double *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			double *pWrk, long *pSync);
void shmem_float_sum_to_all(float *dest, const float *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			float *pWrk, long *pSync);
void shmem_long_sum_to_all(long *dest, const long *source, 
			int nreduce, int PE_start, int logPE_stride,int PE_size, 
			long *pWrk, long *pSync);
void shmem_longdouble_sum_to_all(long double *dest, 
			const long double *source, int nreduce, int PE_start, 
			int logPE_stride, int PE_size, long double *pWrk, 
			long *pSync);
void shmem_longlong_sum_to_all(long long *dest, 
			const long long *source, int nreduce, int PE_start, 
			int logPE_stride, int PE_size, long long *pWrk, 
			long *pSync);
.B FORTRAN: 
CALL SHMEM_COMP4_SUM_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_COMP8_SUM_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT4_SUM_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_SUM_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL4_SUM_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL8_SUM_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL16_SUM_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
.fi
.SS PROD
Performs a product reduction across a set of processing elements (PEs)
.br
.nf
.B C/C++: 
void shmem_complexd_prod_to_all(double complex *dest, 
			const double complex *source, int nreduce, int PE_start, 
			int logPE_stride, int PE_size, double complex *pWrk, 
			long *pSync);
void shmem_complexf_prod_to_all(float complex *dest, 
			const float complex *source, int nreduce, int PE_start, 
			int logPE_stride, int PE_size, float complex *pWrk, 
			long *pSync);
void shmem_short_prod_to_all(short *dest, const short *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			short *pWrk, long *pSync);
void shmem_int_prod_to_all(int *dest, const int *source, int nreduce, 
			int PE_start, int logPE_stride, int PE_size, int *pWrk, 
			long *pSync);
void shmem_double_prod_to_all(double *dest, const double *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			double *pWrk, long *pSync);
void shmem_float_prod_to_all(float *dest, const float *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			float *pWrk, long *pSync);
void shmem_long_prod_to_all(long *dest, const long *source, int nreduce, 
			int PE_start, int logPE_stride, int PE_size, long *pWrk, 
			long *pSync);
void shmem_longdouble_prod_to_all(long double *dest, 
			const long double *source, int nreduce, int PE_start, 
			int logPE_stride, int PE_size, long double *pWrk, 
			long *pSync);
void shmem_longlong_prod_to_all(long long *dest, 
			const long long *source, int nreduce, int PE_start, 
			int logPE_stride, int PE_size, long long *pWrk, 
			long *pSync);
.B FORTRAN: 
CALL SHMEM_COMP4_PROD_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_COMP8_PROD_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT4_PROD_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_PROD_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL4_PROD_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL8_PROD_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL16_PROD_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
.fi
.SS OR
Performs  a  bitwise  OR  function reduction across a set of processing elements (PEs).
.br
.nf
.B C/C++: 
void shmem_short_or_to_all(short *dest, const short *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			short *pWrk, long *pSync);
void shmem_int_or_to_all(int *dest, const int *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			int *pWrk, long *pSync);
void shmem_long_or_to_all(long *dest, const long *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			long *pWrk, long *pSync);
void shmem_longlong_or_to_all(long long *dest, const long long *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			long long *pWrk, long *pSync);
.B FORTRAN: 
CALL SHMEM_INT4_OR_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, 
			PE_size, pWrk, pSync)
CALL SHMEM_INT8_OR_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, 
			PE_size, pWrk, pSync)
.fi
.SS XOR
Performs  a  bitwise  EXCLUSIVE OR reduction across a set of processing elements (PEs).
.br
.nf
.B C/C++: 
void shmem_short_xor_to_all(short *dest, const short *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			short *pWrk, long *pSync);
void shmem_int_xor_to_all(int *dest, const int *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			int *pWrk, long *pSync);
void shmem_long_xor_to_all(long *dest, const long *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			long *pWrk, long *pSync);
void shmem_longlong_xor_to_all(long long *dest, const long long *source, 
			int nreduce, int PE_start, int logPE_stride, int PE_size, 
			long long *pWrk, long *pSync);
.B FORTRAN: 
CALL SHMEM_INT4_XOR_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_XOR_TO_ALL(dest, source, nreduce, PE_start, 
			logPE_stride, PE_size, pWrk, pSync)
.fi
.SH DESCRIPTION
.SS Arguments

.BR "IN " - 
.I dest
- A symmetric array, of length 
.I nreduce
elements, to receive the result of the reduction routines.  The data type of 
.I dest
varies with the version of the reduction routine being called.  When calling from C/C++, refer to the SYNOPSIS section for data type information.

.BR "IN " - 
.I source
- A symmetric array, of length 
.I nreduce
elements, that contains one element for each separate reduction routine.  The 
.I source
argument must have the same data type as 
.IR "dest" .

.BR "IN " - 
.I nreduce
- The number of elements in the 
.I dest
and 
.I source
arrays.  
.I nreduce
must be of type integer.  If you are using Fortran, it must be a default integer value.

.BR "IN " - 
.I PE\_start
- The lowest 
PE
number of the 
.I Active set
of PEs.  
.I PE\_start
must be of type integer.  If you are using Fortran, it must be a default integer value.

.BR "IN " - 
.I logPE\_stride
- The log (base 2) of the stride between consecutive 
PE
numbers in the 
.IR "Active set" .  
.I logPE\_stride
must be of type integer. If you are using Fortran, it must be a default integer value.

.BR "IN " - 
.I PE\_size
- The number of PEs in the 
.IR "Active set" . 
.I PE\_size
must be of type integer.  If you are using Fortran, it must be a default integer value.

.BR "IN " - 
.I pWrk
- A symmetric work array. The 
.I pWrk
argument must have the same data type as \dest. In C/C++, this contains max(
.I nreduce
/2 + 1, 
SHMEM\_REDUCE\_MIN\_WRKDATA\_SIZE
) elements. In Fortran, this contains max(
.I nreduce
/2 + 1, 
SHMEM\_REDUCE\_MIN\_WRKDATA\_SIZE
) elements.

.BR "IN " - 
.I pSync
- A symmetric work array. In C/C++, 
.I pSync
must be of type long and size 
SHMEM\_REDUCE\_SYNC\_SIZE. In Fortran, 
.I pSync
must be of type integer and size 
SHMEM\_REDUCE\_SYNC\_SIZE.  If you are using Fortran, it must be a default integer value. Every element of this array must be initialized with the value 
SHMEM\_SYNC\_VALUE
(in C/C++) or 
SHMEM\_SYNC\_VALUE
(in Fortran) before any of the PEs in the 
.I Active set
enter the reduction routine.
.SS API Description
OpenSHMEM reduction routines compute one or more reductions across symmetric arrays on multiple PEs.  A reduction performs an associative binary routine across a set of values. 

The 
.I nreduce
argument determines the number of separate reductions to perform.  The 
.I source
array on all PEs in the
.I Active set
provides one element for each reduction. The results of the reductions are placed in the 
.I dest
array on all PEs in the 
.IR "Active set" . 
The 
.I Active set
is defined by the 
.IR "PE\_start" ,
.IR "logPE\_stride" , 
.I PE\_size
triplet.  

The 
.I source
and 
.I dest
arrays may be the same array, but they may not be overlapping arrays. 

As with all OpenSHMEM
collective routines, each of these routines assumes that only PEs in the 
.I Active set
call the routine. If a 
PE
not in the 
.I Active set
calls an OpenSHMEM collective routine, undefined behavior results.  

The values of arguments 
.IR "nreduce" , 
.IR "PE\_start" ,
.IR "logPE\_stride" ,
and 
.I PE\_size
must be equal on all PEs in the 
.IR "Active set" . 
The same 
.I dest
and 
.I source
arrays, and the same 
.I pWrk
and 
.I pSync
work arrays, must be passed to all PEs in the 
.IR "Active set" . 

Before any 
PE
calls a reduction routine, you must ensure that the following conditions exist (synchronization via a barrier
or some other method is often needed to ensure this): The 
.I pWrk
and 
.I pSync
arrays on all PEs in the 
.I Active set
are not still in use from a prior call to a collective OpenSHMEM
routine. The 
.I dest
array on all PEs in the 
.I Active set
is ready to accept the results of the
.IR "reduction" . 

Upon return from a reduction routine, the following are true for the local 
PE: The 
.I dest
array is updated and the 
.I source
array may be safely reused. The values in the 
.I pSync
array are restored to the original values.

When calling from Fortran, the 
.I dest
date types are as follows:
.nf
Routine                  | Data type

shmem\_int8\_and\_to\_all    | Integer, with an element size of 8 bytes.

shmem\_int4\_and\_to\_all    | Integer, with an element size of 4 bytes.

shmem\_comp8\_max\_to\_all   | Complex, with an element size equal to 
                           two 8-byte real values.

shmem\_int4\_max\_to\_all    | Integer, with an element size of 4 bytes.

shmem\_int8\_max\_to\_all    | Integer, with an element size of 8 bytes.

shmem\_real4\_max\_to\_all   | Real, with an element size of 4 bytes.

shmem\_real16\_max\_to\_all  | Real, with an element size of 16 bytes.

shmem\_int4\_min\_to\_all    | Integer, with an element size of 4 bytes.

shmem\_int8\_min\_to\_all    | Integer, with an element size of 8 bytes.

shmem\_real4\_min\_to\_all   | Real, with an element size of 4 bytes.

shmem\_real8\_min\_to\_all   | Real, with an element size of 8 bytes.

shmem\_real16\_min\_to\_all  | Real,with an element size of 16 bytes.

shmem\_comp4\_sum\_to\_all   | Complex, with an element size equal to 
                           two 4-byte real values.

shmem\_comp8\_sum\_to\_all   | Complex, with an element size equal to 
                           two 8-byte real values.

shmem\_int4\_sum\_to\_all    | Integer, with an element size of 4 bytes.

shmem\_int8\_sum\_to\_all    | Integer, with an element size of 8 bytes.

shmem\_real4\_sum\_to\_all   | Real, with an element size of 4 bytes.

shmem\_real8\_sum\_to\_all   | Real, with an element size of 8 bytes.

shmem\_real16\_sum\_to\_all  | Real, with an element size of 16 bytes.

shmem\_comp4\_prod\_to\_all  | Complex, with an element size equal to 
                           two 4-byte real values. 
		  
shmem\_comp8\_prod\_to\_all  | Complex, with an element size equal to 
                           two 8-byte real values.

shmem\_int4\_prod\_to\_all   | Integer, with an element size of 4 bytes.

shmem\_int8\_prod\_to\_all   | Integer, with an element size of 8 bytes.

shmem\_real4\_prod\_to\_all  | Real, with an element size of 4 bytes.

shmem\_real8\_prod\_to\_all  | Real, with an element size of 8 bytes.

shmem\_real16\_prod\_to\_all | Real, with an element size of 16 bytes.

shmem\_int8\_or\_to\_all     | Integer, with an element size of 8 bytes.

shmem\_int4\_or\_to\_all     | Integer, with an element size of 4 bytes.

shmem\_int8\_xor\_to\_all    | Integer, with an element size of 8 bytes.

shmem\_int4\_xor\_to\_all    | Integer, with an element size of 4 bytes.
.fi
.SS Return Values
None.
.SS API Notes
All OpenSHMEM reduction routines reset the values in 
.I pSync
before they return, so a particular 
.I pSync
buffer need only be initialized the first time it is used. You must ensure that the 
.I pSync
array is not being updated on any 
PE
in the 
.I Active set
while any of the PEs participate in processing of an OpenSHMEM
reduction routine. Be careful to avoid the following situations: If the 
.I pSync
array is initialized at run time, some type of synchronization is needed to ensure that all PEs in the working set have initialized 
.I pSync
before any of them enter an OpenSHMEM routine called with the 
.I pSync
synchronization array. A 
.I pSync
or 
.I pWrk
array can be reused in a subsequent reduction routine call only if none of the PEs in the 
.I Active set
are still processing a prior reduction routine call that used the same 
.I pSync
or 
.I pWrk
arrays. In general, this can be assured only by doing some type of synchronization. 
.SS Example
.SS AND
This Fortran reduction example statically initializes the 
.I pSync
array and finds the logical
AND
of the integer variable 
FOO
across all even PEs.

./
.nf
INCLUDE "shmem.fh"

INTEGER PSYNC(SHMEM_REDUCE_SYNC_SIZE)
DATA PSYNC /SHMEM_REDUCE_SYNC_SIZE*SHMEM_SYNC_VALUE/
PARAMETER (NR=1)
INTEGER*4 PWRK(MAX(NR/2+1,SHMEM_REDUCE_MIN_WRKDATA_SIZE))
INTEGER FOO, FOOAND
SAVE FOO, FOOAND, PWRK
INTRINSIC SHMEM_MY_PE()

FOO = SHMEM_MY_PE()
IF ( MOD(SHMEM_MY_PE() .EQ. 0) THEN
   IF ( MOD(SHMEM_N_PES()(),2) .EQ. 0) THEN
      CALL SHMEM_INT8_AND_TO_ALL(FOOAND, FOO, NR, 0, 1, NPES/2, &
	 PWRK, PSYNC)
   ELSE
      CALL SHMEM_INT8_AND_TO_ALL(FOOAND, FOO, NR, 0, 1, NPES/2+1, &
	 PWRK, PSYNC)
  
   ENDIF
   PRINT*,'Result on PE ',SHMEM_MY_PE(),' is ',FOOAND
ENDIF
.fi



.SS MAX
This Fortran example statically initializes the 
.I pSync
array and finds the MAX value of real variable 
FOO
across all even PEs.

./
.nf
INCLUDE "shmem.fh"

INTEGER PSYNC(SHMEM_REDUCE_SYNC_SIZE)
DATA PSYNC /SHMEM_REDUCE_SYNC_SIZE*SHMEM_SYNC_VALUE/
PARAMETER (NR=1)
REAL FOO, FOOMAX, PWRK(MAX(NR/2+1,SHMEM_REDUCE_MIN_WRKDATA_SIZE))
COMMON /COM/ FOO, FOOMAX, PWRK
INTRINSIC SHMEM_MY_PE()

IF ( MOD(SHMEM_MY_PE() .EQ. 0) THEN
      CALL SHMEM_REAL8_MAX_TO_ALL(FOOMAX, FOO, NR, 0, 1, N$PES/2,
&	 PWRK, PSYNC)
      PRINT*,'Result on PE ',SHMEM_MY_PE(),' is ',FOOMAX
ENDIF

.fi



.SS MIN
This Fortran example statically initializes the 
.I pSync
array and finds the MIN
value of real variable 
FOO
across all the even PEs.

./
.nf
INCLUDE "shmem.fh"

INTEGER PSYNC(SHMEM_REDUCE_SYNC_SIZE)
DATA PSYNC /SHMEM_REDUCE_SYNC_SIZE*SHMEM_SYNC_VALUE/
PARAMETER (NR=1)
REAL FOO, FOOMIN, PWRK(MAX(NR/2+1,SHMEM_REDUCE_M.BR "IN " - 
.I _WRKDATA_SIZE))
COMMON /COM/ FOO, FOOMIN, PWRK
INTRINSIC SHMEM_MY_PE()

IF ( MOD(SHMEM_MY_PE() .EQ. 0) THEN
      CALL SHMEM_REAL8_MIN_TO_ALL(FOOMIN, FOO, NR, 0, 1, N$PES/2,
&	 PWRK, PSYNC)
      PRINT*,'Result on PE ',SHMEM_MY_PE(),' is ',FOOMIN
ENDIF
.fi



.SS SUM
This Fortran example statically initializes the 
.I pSync
array and finds the SUM
of the real variable 
FOO
across all even PEs.

./
.nf
INCLUDE "shmem.fh"

INTEGER PSYNC(SHMEM_REDUCE_SYNC_SIZE)
DATA PSYNC /SHMEM_REDUCE_SYNC_SIZE*SHMEM_SYNC_VALUE/
PARAMETER (NR=1)
REAL FOO, FOOSUM, PWRK(MAX(NR/2+1,SHMEM_REDUCE_MIN_WRKDATA_SIZE))
COMMON /COM/ FOO, FOOSUM, PWRK
INTRINSIC SHMEM_MY_PE()

IF ( MOD(SHMEM_MY_PE() .EQ. 0) THEN
      CALL SHMEM_INT4_SUM_TO_ALL(FOOSUM, FOO, NR, 0, 1, N$PES/2,
&	 PWRK, PSYNC)
      PRINT*,'Result on PE ',SHMEM_MY_PE(),' is ',FOOSUM
ENDIF
.fi



.SS PROD
This Fortran example statically initializes the 
.I pSync
array and finds the PRODUCT
of the real variable 
FOO
across all the even PEs.

./
.nf
INCLUDE "shmem.fh"

INTEGER PSYNC(SHMEM_REDUCE_SYNC_SIZE)
DATA PSYNC /SHMEM_REDUCE_SYNC_SIZE*SHMEM_SYNC_VALUE/
PARAMETER (NR=1)
REAL FOO, FOOPROD, PWRK(MAX(NR/2+1,SHMEM_REDUCE_MIN_WRKDATA_SIZE))
COMMON /COM/ FOO, FOOPROD, PWRK
INTRINSIC SHMEM_MY_PE()

IF ( MOD(SHMEM_MY_PE() .EQ. 0) THEN
       CALL SHMEM_COMP8_PROD_TO_ALL(FOOPROD, FOO, NR, 0, 1, N$PES/2,
&	 PWRK, PSYNC)
       PRINT*,'Result on PE ',SHMEM_MY_PE(),' is ',FOOPROD
ENDIF
.fi



.SS OR
This Fortran example statically initializes the 
.I pSync
array and finds the logical OR
of the integer variable 
FOO
across all even PEs.

./
.nf
INCLUDE "shmem.fh"

INTEGER PSYNC(SHMEM_REDUCE_SYNC_SIZE)
DATA PSYNC /SHMEM_REDUCE_SYNC_SIZE*SHMEM_SYNC_VALUE/
PARAMETER (NR=1)
REAL PWRK(MAX(NR/2+1,SHMEM_REDUCE_MIN_WRKDATA_SIZE))
INTEGER FOO, FOOOR
COMMON /COM/ FOO, FOOOR, PWRK
INTRINSIC SHMEM_MY_PE()

IF ( MOD(SHMEM_MY_PE() .EQ. 0) THEN
       CALL SHMEM_INT8_OR_TO_ALL(FOOOR, FOO, NR, 0, 1, N$PES/2,
&	 PWRK, PSYNC)
       PRINT*,'Result on PE ',SHMEM_MY_PE(),' is ',FOOOR
ENDIF
.fi



.SS XOR
This Fortran example statically initializes the 
.I pSync
array and computes the exclusive
XOR
of variable 
FOO
across all even PEs.

./
.nf
INCLUDE "shmem.fh"

INTEGER PSYNC(SHMEM_REDUCE_SYNC_SIZE)
DATA PSYNC /SHMEM_REDUCE_SYNC_SIZE*SHMEM_SYNC_VALUE/
PARAMETER (NR=1)
REAL FOO, FOOXOR, PWRK(MAX(NR/2+1,SHMEM_REDUCE_MIN_WRKDATA_SIZE))
COMMON /COM/ FOO, FOOXOR, PWRK
INTRINSIC SHMEM_MY_PE()

IF ( MOD(SHMEM_MY_PE() .EQ. 0) THEN
      CALL SHMEM_REAL8_XOR_TO_ALL(FOOXOR, FOO, NR, 0, 1, N$PES/2,
&	 PWRK, PSYNC)
      PRINT*,'Result on PE ',SHMEM_MY_PE(),' is ',FOOXOR
ENDIF
.fi

