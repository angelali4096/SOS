.TH SHMEM_COLLECT 1 2017-06-06 "Intel Corp." "OpenSHEMEM Library Documentation"
.SH NAME
shmem_collect \-  Concatenates blocks of data from multiple PE to an array in every 
PE.
.SH SYNOPSIS
.nf
.B C/C++: 
void shmem_collect32(void *dest, const void *source, size_t nelems, 
            int PE_start, int logPE_stride, int PE_size, long *pSync);
void shmem_collect64(void *dest, const void *source, size_t nelems, 
            int PE_start, int logPE_stride, int PE_size, long *pSync);
void shmem_fcollect32(void *dest, const void *source, size_t nelems, 
            int PE_start, int logPE_stride, int PE_size, long *pSync);
void shmem_fcollect64(void *dest, const void *source, size_t nelems, 
            int PE_start, int logPE_stride, int PE_size, long *pSync);
.B FORTRAN: 
INTEGER nelems
INTEGER PE_start, logPE_stride, PE_size
INTEGER pSync(SHMEM_COLLECT_SYNC_SIZE)
CALL SHMEM_COLLECT4(dest, source, nelems, PE_start, logPE_stride, 
      PE_size, pSync)
CALL SHMEM_COLLECT8(dest, source, nelems, PE_start, logPE_stride, 
      PE_size, pSync)
CALL SHMEM_COLLECT32(dest, source, nelems, PE_start, logPE_stride, 
      PE_size, pSync)
CALL SHMEM_COLLECT64(dest, source, nelems, PE_start, logPE_stride, 
      PE_size, pSync)
CALL SHMEM_FCOLLECT4(dest, source, nelems, PE_start, logPE_stride, 
      PE_size, pSync)
CALL SHMEM_FCOLLECT8(dest, source, nelems, PE_start, logPE_stride, 
      PE_size, pSync)
CALL SHMEM_FCOLLECT32(dest, source, nelems, PE_start, logPE_stride, 
      PE_size, pSync)
CALL SHMEM_FCOLLECT64(dest, source, nelems, PE_start, logPE_stride, 
      PE_size, pSync)
.fi
.SH DESCRIPTION
.SS Arguments

.BR "OUT " - 
.I dest
- A symmetric array. The 
.I dest
argument must be large enough to accept the concatenation of the 
.I source
arrays on all PEs.  The data types are as follows: For 
.BR "shmem\_collect8" ,
.BR "shmem\_collect64" ,
.BR "shmem\_fcollect8" ,
and 
.BR "shmem\_fcollect64" ,
any data type with an element size of 64 bits. Fortran derived types, Fortran character type, and C/C++ structures are not permitted. For 
.BR "shmem\_collect4" ,
.BR "shmem\_collect32" ,
.BR "shmem\_fcollect4" ,
and 
.BR "shmem\_fcollect32" ,
any data type with an element size of 32 bits. Fortran derived types, Fortran character type, and C/C++ structures are not permitted.

.BR "IN " - 
.I source
- A symmetric data object that can be of any type permissible for the 
.I dest
argument.

.BR "IN " - 
.I nelems
- The number of elements in the 
.I source
array. 
.I nelems
must be of type 
size\_t
for C. If you are using Fortran, it must be a default integer value.

.BR "IN " - 
.I PE\_start
- The lowest PE number of the 
.I Active set
of PEs.  
.I PE\_start
must be of type integer. If you are using Fortran, it must be a default integer value.

.BR "IN " - 
.I logPE\_stride
- The log (base 2) of the stride between consecutive PE
numbers in the 
.IR "Active set" . 
.I logPE\_stride
must be of type integer.  If you are using Fortran, it must be a default integer value.

.BR "IN " - 
.I PE\_size
- The number of PEs in the 
.IR "Active set" . 
.I PE\_size
must be of type integer.  If you are using  Fortran, it must be a default integer value.

.BR "IN " - 
.I pSync
- A symmetric  work array.  In C/C++, 
.I pSync
must be of type long and size 
SHMEM\_COLLECT\_SYNC\_SIZE.  In Fortran, 
.I pSync
must be of type integer and size 
SHMEM\_COLLECT\_SYNC\_SIZE. If you are using Fortran, it must be a default integer value.  Every element of this array must be initialized with the value 
SHMEM\_SYNC\_VALUE in C/C++ or SHMEM\_SYNC\_VALUE
in Fortran before any of the PEs in the 
.I Active set
enter 
.B shmem\_collect
or 
.BR "shmem\_fcollect" .
.SS API Description
OpenSHMEM
.B collect
and 
.B fcollect
routines concatenate 
.I nelems
64-bit or 32-bit data items from the 
.I source
array into the 
.I dest
array, over the set of PEs defined by 
.IR "PE\_start" , 
.IR "log2PE\_stride" ,
and 
.IR "PE\_size" ,
in processor number order. The resultant 
.I dest
array contains the contribution from 
PE
.I PE\_start
first, then the contribution from 
PE
.I PE\_start
+ 
.I PE\_stride
second, and so on. The collected result is written to the 
.I dest
array for all PEs in the 
.IR "Active set" .

The 
.B fcollect
routines require that 
nelems
be the same value in all participating PEs, while the 
.B collect
routines allow 
.I nelems
to vary from 
PE
to 
PE.  

As with all OpenSHMEM collective routines, each of these routines assumes that only PEs in the 
.I Active set
call the routine. If a 
PE
not in the 
.I Active set
and calls this collective routine, the behavior is undefined.  

The values of arguments 
.IR "PE\_start" , 
.IR "logPE\_stride" ,
and 
.I PE\_size
must be equal on all PEs in the 
.IR "Active set" . 

The same 
.I dest
and 
.I source
arrays and the same 
.I pSync
work array must be passed to all PEs in the 
.IR "Active set" .  

Upon return from a collective routine, the following are true for the local 
PE
: The 
.I dest
array is updated and the 
.I source
array may be safely reused. The values in the 
.I pSync
array are restored to the original values.
.SS Return Values
None.
.SS API Notes
All OpenSHMEM collective routines reset the values in 
.I pSync
before they return, so a particular 
.I pSync
buffer need only be initialized the first time it is used. 

You must ensure that the 
.I pSync
array is not being updated on any 
PE
in the 
.I Active set
while any of the PEs participate in processing of an OpenSHMEM collective routine.  Be careful to avoid these situations: If the 
.I pSync
array is initialized at run time, some type of synchronization is needed to ensure that all PEs in the working set have initialized 
.I pSync
before any of them  enter an OpenSHMEM routine called with the 
.I pSync
synchronization array.  A 
.I pSync
array can be reused on a subsequent OpenSHMEM collective routine only if none of the PEs in the 
.I Active set
are still processing a prior OpenSHMEM collective routine call that used the same 
.I pSync
array. In general, this may be ensured only by doing some type of synchronization. 

The collective routines operate on active PE sets that have a non-power-of-two 
.I PE\_size
with some performance degradation. They operate with no performance degradation when 
.I nelems
is a non-power-of-two value.
.SS Example

The following 
.BR "shmem\_collec" t
example is for C/C++

programs:

./
.nf
#include <stdio.h>
#include <stdlib.h>
#include <shmem.h>

int main(void)
{
  static long lock = 0;
  static long pSync[SHMEM_COLLECT_SYNC_SIZE];
  for (int i = 0; i < SHMEM_COLLECT_SYNC_SIZE; i++)
     pSync[i] = SHMEM_SYNC_VALUE;

  shmem_init();
  int me = shmem_my_pe();
  int npes = shmem_n_pes();
  int my_nelem = me + 1; 
  /* linearly increasing number of elements with PE */
  int total_nelem = (npes * (npes + 1)) / 2;

  int* source = (int*) shmem_malloc(npes*sizeof(int)); 
  /* symmetric alloc */
  int* dest = (int*) shmem_malloc(total_nelem*sizeof(int));

  for (int i = 0; i < my_nelem; i++)
     source[i] = (me * (me + 1)) / 2 + i;
  for (int i = 0; i < total_nelem; i++)
     dest[i] = -9999;

  shmem_barrier_all(); /* Wait for all PEs to update source/dest */

  shmem_collect32(dest, source, my_nelem, 0, 0, npes, pSync);

  shmem_set_lock(&lock); /* Lock prevents interleaving printfs */
  printf("%d: %d", me, dest[0]);
  for (int i = 1; i < total_nelem; i++)
     printf(", %d", dest[i]);
  printf("\\n");
  shmem_clear_lock(&lock);
  shmem_finalize();
  return 0;
}

.fi




The following 
.B SHMEM\_COLLECT
example is for Fortran programs:

./
.nf
INCLUDE "shmem.fh"

INTEGER PSYNC(SHMEM_COLLECT_SYNC_SIZE)
DATA PSYNC /SHMEM_COLLECT_SYNC_SIZE*SHMEM_SYNC_VALUE/

CALL SHMEM_COLLECT4(DEST, SOURCE, 64, PE_START, LOGPE_STRIDE,
&  PE_SIZE, PSYNC)
.fi



