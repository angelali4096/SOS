.TH SHMEM_WAIT 1 2017-06-06 "Intel Corp." "OpenSHEMEM Library Documentation"
.SH NAME
shmem_wait \-  Wait for a variable on the local 
PE
to change.
.SH SYNOPSIS
.nf
.B C11: 
void shmem_wait_until(TYPE *ivar, shmem_cmp_t cmp, TYPE cmp_value);
void shmem_wait(TYPE *ivar, TYPE cmp_value);
.B C/C++: 
void shmem_<TYPENAME>_wait_until(TYPE *ivar, shmem_cmp_t cmp, 
			TYPE cmp_value);
void shmem_<TYPENAME>_wait(TYPE *ivar, TYPE cmp_value);

* TYPE is one of the point-to-point synchronization types
.B FORTRAN: 
CALL SHMEM_INT4_WAIT(ivar, cmp_value)
CALL SHMEM_INT4_WAIT_UNTIL(ivar, cmp, cmp_value)
CALL SHMEM_INT8_WAIT(ivar, cmp_value)
CALL SHMEM_INT8_WAIT_UNTIL(ivar, cmp, cmp_value)
CALL SHMEM_WAIT(ivar, cmp_value)
CALL SHMEM_WAIT_UNTIL(ivar, cmp, cmp_value)
.fi
.SH DESCRIPTION
.SS Arguments

.BR "OUT " - 
.I 
ivar
- A remotely accessible integer variable that is being updated by another 
PE.  If you are using C/C++, the type of 
.I ivar
should match that implied in the SYNOPSIS section.

.BR "IN " - 
.I 
cmp
- The compare operator that compares 
.I ivar
with  
.IR "cmp\_value" .  
If you are using Fortran, it must  be of default kind.  If you are using C/C++, it must be of type shmem\_cmp\_t.

.BR "IN " - 
.I cmp\_value
-
.I cmp\_value
must be of type integer.  If you are using C/C++, the type of 
.I cmp\_value
should match that implied in the SYNOPSIS section. If you are using Fortran, 
.I cmp\_value 
must be an integer of the same size and kind as 
.IR "ivar" .
.SS API Description
 
.B shmem\_wait
and 
.B shmem\_wait\_until
wait for 
.I ivar
to be changed by a remote write or an atomic operation issued by a different 
PE. These routines can be used for point-to-point direct synchronization.  A call to 
.B shmem\_wait
does not return until some other 
PE
writes  a value, not equal to 
.IR "cmp\_value" ,
into 
.I ivar
on the waiting 
PE.  A call to 
.B shmem\_wait\_until
does not return until some  other 
PE
changes 
.I ivar
to satisfy the condition implied by 
.I cmp
and 
.IR "cmp\_value" .
This mechanism is useful when a 
PE
needs to tell another 
PE
that it has completed some action.  The 
.B shmem\_wait
routines return when 
.I ivar
is no  longer  equal  to 
.IR "cmp\_value" .
The 
.B shmem\_wait\_until
routines return when the compare condition is true. The compare condition is defined by the 
.I ivar
argument  compared with the 
.I cmp\_value
using the comparison operator, 
.IR "cmp" .

If you are using Fortran, 
.I ivar
must be a specific sized integer type according to the routine being called, as follows:
.nf
Routine                       | Data type

shmem\_wait, shmem\_wait\_until  | default INTEGER

shmem\_int4\_wait,              | INTEGER*4
shmem\_int4\_wait\_until

shmem\_int8\_wait,              | INTEGER*8
shmem\_int8\_wait\_until
.fi
.SS Return Values
None.
.SS API Notes
As of OpenSHMEM 1.4, the 
.B shmem\_wait
routine is deprecated,  however, 
.B shmem\_wait
is equivalent to 
.B shmem\_wait\_until
where 
.I cmp
is SHMEM\_CMP\_NE.
.SS Note to implementors
Implementations must ensure that 
.B shmem\_wait
and 
.B shmem\_wait\_until
do not return before the update of the memory indicated by 
.I ivar
is fully complete. Partial updates to the memory must not cause 
.B shmem\_wait
or 
.B shmem\_wait\_until
to return.
.SS Example

The following call returns when variable 
.I ivar
is not equal to 100:

./
.nf
INCLUDE "shmem.fh"

INTEGER*8 IVAR
CALL SHMEM_INT8_WAIT(IVAR, INTEGER*8(100))
.fi




The following call to 
.B SHMEM\_INT8\_WAIT\_UNTIL
is equivalent to the call to 
.B SHMEM\_INT8\_WAIT
in example 1:

./
.nf
INCLUDE "shmem.fh"

INTEGER*8 IVAR
CALL SHMEM_INT8_WAIT_UNTIL(IVAR, SHMEM_CMP_NE, INTEGER*8(100))
.fi




The following C/C++ call waits until the value in 
.I ivar
is set to be less than zero by a transfer from a remote PE:

./
.nf
#include <stdio.h>
#include <shmem.h>

int ivar;
shmem_int_wait_until(&ivar, SHMEM_CMP_LT, 0);
.fi




The following Fortran example is in the context of a subroutine:

./
.nf
INCLUDE "shmem.fh"

SUBROUTINE EXAMPLE()
INTEGER FLAG_VAR
COMMON/FLAG/FLAG_VAR
. . .
FLAG_VAR = FLAG_VALUE    !  initialize the event variable
. . .
IF (FLAG_VAR .EQ.  FLAG_VALUE) THEN
        CALL SHMEM_WAIT(FLAG_VAR, FLAG_VALUE)
ENDIF
FLAG_VAR = FLAG_VALUE    !  reset the event variable for next time
. . .
END
.fi



